この章でやること

- アプリケーションの名前を決める
- アプリケーションの雛形を作成する
- データベースを作成する
- ビュー層を効率よく書くためにslimを使えるようにする
- アプリケーションの見栄えをよくするためにBootstrapを導入する
- railsのエラーメッセージ等を日本語で出せるようにする

# 3-1

## データベースの環境毎の使い分け

railsではデフォルトで3種類の環境が用意されており、1つの環境に対して1つのデータベースを対応させる。

|種類|システム名|用途|
--|--|--
|開発|development|開発時の動作確認を行う|
|テスト|test|自動テストを行う|
|本番|production|ユーザーが利用可能な形で稼働させる|

どの環境にどのようなデータベースを対応させるかは、config/database.ymlに記載する。


## slimを使えるようにする
slimはテンプレートエンジンの１つ。
利用すると、アプリケーションの画面をHTMLの構造が直感的にわかりやすいテンプレート形式で書くことができる。

## bootstrapを導入する
bootstrapはフロントエンドフレームワークの1つ。
手軽に程よく見栄えの良い画面を作成することができる。

## scssを利用する
rails newをした直後ではrailsはアプリケーション全体で1つのCSSファイルを読み込むようになっている。
今回はSCSSの記法でCSSを記述してみる。
新しくSCSS(applications.scss)を作成する。
上に伴い、もとからあるCSSファイルは削除する。

```
$ rm app/assets/stylesheets/application.css
```

次にSCSSファイルを作成する。
(詳細は書籍の方を参照)

これで各画面にBootstrapのデザインを反映できる状態になった。


## railsのエラーメッセージを日本語で出せるようにする
今回作るアプリは日本語のアプリケーションにしたいので、日本語の翻訳を追加して利用する言語を日本語に設定する。
日本語翻訳ファイルを持ってくる(書籍ではwgetを使っているが、macではそのコマンドが使えないのでcurlで叩く)
```
$ curl -o config/locales/ja.yml -L https://raw.github.com/svenfuchs/rails-i18n/master/rails/locale/ja.yml
```

# 3-2

railsのモデルは主に2つの要素から構成されている
- モデルに対するrubyのクラス
- モデルに対するデータベースのテーブル

モデルのクラス名とデータベースのテーブル名には以下のような命名の規約がある
- データベースのテーブル名はモデルのクラス名を複数系にしたもの
- モデルのクラス名はキャメルケース、テーブルはスネークケース

## タスクモデルの雛形を作成する
タスクモデルの生成にはジェネレータを利用する
ジェネレータはrails gの後に生成したいものの種類を指定し、更に生成したいものの種類ごとの必要な情報を添えて実行する。

```
bin/rails g model [モデル名] [属性名:データ型 属性名:データ型 ...] [オプション]
```

## マイグレーションでデータベースにテーブルを追加する
データベースにテーブルを追加するには、railsの用意しているマイグレーションという仕組みを使う。
マイグレーション: データベーススキーマへ変更の1つ1つをrubyのプログラムとして実現し、開発の歴史に沿って順番に実行することで最新のスキーマの状態にできるようにすること。
マイグレーションはスキーマの歴史をすすめるだけでなく戻す機能も備えているので、必要なところまでデータベースのスキーマの状態を戻す事ができる。

マイグレーションをデータベースに適用するには、rails db:migrateマンドを利用する

# 3-3
モデルが作成できたので、コントローラとビューを実装して、ブラウザ上で各操作を行えるようにする。
モデルと同様、コントローラとビューの雛形もジェネレータで作成することができる。

```
bin/rails g controller コントローラ名　[アクション名 アクション名 ...] [オプション]
```

アクション: リクエストに対しての処理を実行するためのメソッド。
具体的にはモデルを呼び出したり、画面を表示したりする。

<ここで抑えておくこと>
- リクエストを処理するコントローラとアクションは、ブラウザからのリクエストに含まれるURLとHTTPメソッドによって決定される。
- コントローラのアクションを設計する際には、入口となるURLとHTTPメソッドをあわせて考える必要がある。

## 新規登録機能を実装する

### 一覧画面に新規登録リンクを追加する
今回はbtnとbtn-primaryという2つのCSSクラスを与える。
link_toメソッドは<a href='...'></a>というようなHTMLの要素を出力するメソッド

### モデルの翻訳情報を追加する
Taskモデルの翻訳情報をconfig/locals/ja.ymlに追加しておく。
モデルの名前はactiverecodeのmodelsの下に、属性の名前はactiverecordのattributesにそれぞれ定義する

### 新規登録画面のためのアクションを実装する
新しいTaskオブジェクトを生成してインスタンス変数@taskに代入しておく
コントローラーのインスタンス変数は、ビューからも見ることができる。
アクションからビューに受け渡しをしたいデータをインスタンス変数に入れることが、アクションの基本的な役割の一つになる。

### アクションへデータを送る「リクエストパラメータ」

リクエストパラメータ: リクエストにデータを添える際のデータのこと。

リクエストパラメータの送り方はHTTPの仕組みの上で2通りに分かれる。
- POSTで送る。基本的にはHTMLのform要素をsubmitすることで送られる
- GETで送る。基本的にはURLの?以降に情報を含めることで送る。普通に?のついたURLにブラウザからアクセスする他、form要素のmethod属性にgetを指定して、form要素のsubmitを通じてそのようなリクエストを送ることもできる。

### 新規登録画面のビューを実装する
この画面では、先程アクションで用意した新しいタスクのオブジェクト(@task)を利用して、登録フォームを表示する。
それにはfotm_withというメソッドを利用する。
form_with: モデルオブジェクトを使ってHTMLのform要素を作成するためのメソッド

### 登録アクションを実装する
登録アクションはTaskControllerのcreateアクションとして実装する。
ここに「登録フォームから送られてきたデータをデータベースに保存して、一覧画面に遷移する」という処理を書いていく

task_paramsメソッドはフォームからリクエストパラメータとして送られてきた情報が想定通りに{task:{...}}の形であるかをチャックし、{...}の中から、受け付ける想定である情報だけを抜き取るという役割をしている。
これは、受け取る想定でない情報を悪意あるユーザーが送りつけて来た場合に、それがモデルに入力され、結果として不正なデータが登録・更新されてしまうことを防ぐため。

### レンダーとリダイレクト
レンダー: アクションに続けてビューを表示させる。
リダイレクト: アクションを処理した直後にビューを表示せず、別のURLに案内する動き。

### flashメッセージ
flash: リダイレクトの際に次のリクエストに対してちょっとしたデータを伝えるためにrailsが用意している仕組み。
ハッシュの形でデータを格納できる

## 一覧表示機能を実装する

### 一覧表示アクションでタスクデータを取得する
indexアクションでビューを利用したい全タスクのデータを取得して、ビューに伝えるためのインスタンス変数に格納する。
ここでは、データベースに保存されているすべてのタスクデータを取得するために、Task.allというメソッドを使う
このメソッドの戻り値を@tasksというインスタンス変数に代入して、ビューに伝える。
@tasksは得られたすべてのタスクオブジェクトの配列が格納されているのと似た状態になる。

### 一覧画面ですべてのタスクデータを表示する
次にビューを実装。
テーブルと見出し行を用意した上で、@tasks.eachでTaskオブジェクトを1つずつ取り出し、タスク1つにつき1行を表示するようにする。

### 詳細表示機能を実装する
今回は一覧画面内のタスクの名称をクリックしたら詳細画面に遷移するということにする。
なので、index.html.slimのタスク名称を表示している部分を変更する。
`link_to`を加えることにより、名称の部分をリンクにする。


### 指定されたタスクを詳細表示アクションで取得する
ここではfindというメソッドを使って、書斎画面に表示するためのTaskオブジェクトを取得している。
findはidによってモデルオブジェクトに対応するレコードをデータベースから検索する。引数としてparams[:id]を渡している。


### 詳細画面にタスクの属性情報を表示する
ビューを修正し、タスクの各属性の内容を表示するようにする。
また、一覧画面へのリンクも設置しておく。

simple_formatメソッド: 複数行に渡るテキストを入力できるようにするためのメソッド

### 編集機能を実装する
一覧画面と詳細画面に編集画面へのリンクを設置する。
次にアクションを実装する。
編集機能では、編集画面を表示するeditアクションと、画面から送られてきたデータを使ってデータベースを更新するupdateアクションの2つが必要になる。

※ tasks_controller.rb上の処理↓
editアクションでは、登録済みのデータをフォーム画面に予め表示できるように、URL内に含まれるタスクのidをパラメータから受け取り、それを用いてデータベースを検索して、編集対象のTaskオブジェクトを取得する。それを@taskというインスタンス変数に代入して、フォーム画面で利用できるようにする。

updateアクションでは、同様に編集対象のTaskオブジェクトを取得して、update!メソッドによってtaskパラメータの代入とデータベースへの保存の両方を行っている。
taskパラメータの取得には、新規登録機能の実装時に作成したtask_paramsというメソッドを再び利用している。最後にflashメッセージを添えて一覧画面に遷移を行う。

### パーシャルをつかた新規登録画面と編集画面の共通化
newとedit画面の構造が同じなので、これを共通化する。
共通化にはrenderメソッドのパーシャルオプションを使う

パーシャルテンプレートのファイル名には先頭にアンダースコアを付ける。

## 削除機能を実装する
削除ボタンは削除アクションにDELETEメソッドで遷移するためのリンクとして追加する。
削除アクションへのリンクはmethod: deleteという指定により、DELETEメソッドでリクエストされるようになる。
また、link_toのdataオプションに"confirm:"を渡すと、リンクをクリックした際に確認ダイアログを出し、OKが押されたときだけリンク先のURLへのリクエストを行ってくれるようになる。

destroyアクションでは詳細表示や編集のときと同様にパラメータ経由で対象タスクのidを受け取り、Taskオブジェクトをデータベースから取得する。そのうえで、destroyメソッドによって対応するタスクレコードをデータベースから削除し、削除した旨を伝えるflashメッセージと共に一覧画面に遷移させる。
