この章でやること
マイグレーション理解の幅を広げる

# 4-1

## マイグレーションの適用を理解する
マイグレーションは基本的に以下の2ステップで行う
1. DBの構造を適用するコードをRubyで記述した「マイグレーション」ファイルを作成する
2. 削除したマイグレーションファイルをrails:db:migrateコマンドを使ってデータベースに適用する(migrateする)

マイグレーションにおいては1つのマイグレーションファイが**1つのバージョン**として扱われる。
つまり、1つのマイグレーションを適用することでデータベーススキーマのバージョンを1つ上げることができ、適用済みのマイグレーションを１つ取り消すことでバージョンを1つ下げることができる。

マイグレーションファイルを作成しただけではデータベースは変更されない。
マイグレーションを適用して初めて、マイグレーションファイルに書かれたrubyコードが実行され、データベースが実際に変更される。
逆にマイグレーションを取り消す際もマイグレーションを取り消すコマンドを実行してマイグレーションファイルに書かれた取り消し操作を適用する必要がある。


## マイグレーションの名前の付け方に注意
マイグレーションの名前はアプリケーション内で一意(オンリーワン)である必要がある。

## schema.rb
railsは現在のデータベースの構造をdb/schema.rbというファイルに自動出力する。
このファイルはマイグレーションを適用したり外したりすると自動的に出力される。
また、db:schema:dumpコマンドで手動で出力することもできる。
schema.rbは自動テスト環境などで使用される他、視覚的にテーブル・絡む構造を確認できるため、データベースについての手軽なドキュメントとして利用することもできる。


# 4-2
データの内容を制限数する

データには、想定される内容の範囲がある。
(カラムの値が常に数値なのか、値が入らないことがあるのか?)

内容の範囲の中にはデータベースで定義することでそぐわない値が格納されないようにできるものがある。
一般的には以下のような定義要素。

- データ型
- NOT NULL制約
- 文字列カラムの長さを指定する
- ユニークインデックス

## データ型
データベースのカラムには方を指定する。

## NOT NULL制約
データベーステーブルのカラムの値としてNULLを格納する必要がない場合には、NOT NULL制約をつけることで、物理的にNULLできないようにしてくれる。

### taskテーブルのnameカラムにNOT NULL制約をつける
すでに作ってあるテーブルのカラムに後から制約をつける際にもマイグレーションを利用する。
まずはマイグレーションの雛形ファイルを作る。
マイグレーションの雛形を作ったら、生成したファイルの中身を変更する。
(書籍参照)
change_column_nullを使うと、既存のテーブルの既存のカラムのNOYT NULL制約をつけたり外したりすることができる。
編集したら、マイグレーションをデータベースに適用する。


## 文字列カラムの長さを指定する
絡む定義で文字列の長さを指定することで、必要以上に長いデータ保存されることを防ぐ事ができる。
マイグレーションで文字列カラムに対して文字列の長さを指定するには、limitオプションを使う。


## ユニークインデックスを作成する
カラムのデータが全レコード内で一意である場合には、データベースにユニークインデックスを作成することで、一意性が壊されるのを防ぐことができる。

仮にTaskモデルのname属性をシステム内で一意にしたいとすれば、taskテーブル作成時にnameカラムに対してユニークインデックスを作成するのが良い

# モデルの「検証」を使う
データの内容が正しいかどうかをチェックする仕組みのことを検証(validation)という
railsのモデルにも検証の仕組み通いされている。


## モデルの検証の仕組み
railsにおけるモデルの検証は基本的に「モデルオブジェクトをデータベースに登録・更新する前に検証を行い、エラーがあれば登録・更新をしないで差し戻す」という仕組みになっている。
この仕組に対応する登録・更新のためのメソッドがsave。

saveメソッド: データベースの登録・更新を行う前に自動的に検証を行い、検証エラーがあればfalseを返す。
検証エラーがなければ、データベースへの登録・更新を行ってtrueを返す。

検証は、検証処理単独でも呼ぶことができる。それにはvalid?というメソッドを利用する。

## 検証の書き方
検証コードを書く方法には大きくわけて2通りある

1. railsが用意している検証用のヘルパーを利用する
2. 自分で任意の検証コードを書く

webアプリケーションでよくある検証要件に対しては、railsが検証用のヘルパーを用意してくれている。


## 検証を追加する
例として「taskleafアプリケーションのTaskモデルのname属性の値が入っていなければ検証エラーになる」という検証を追加してみる。


## コントローラとビューで検証エラーに対応する

tasks_controlloer.rbを変更する

<変更点>

1. 登録のために用いるメソッドの変更
save!ではなくsaveを利用して、どの戻り値によって制御を変えるようにしている

2. 検証エラーのときの処理の追加
結果がfalseだったときは、render :newによって、登録用のフォーム画面を再び表示て、ユーザー二再入力を促す

3. Taskオブジェクトを@taskというインスタンス変数に代入するようにする
検証エラーがあってもう一度新規登録画面を表示する際に、ビューに検証を行った現物のTaskオブジェクトを渡す必要があるから。


## 文字列長の検証を追加する
30文字を超える入力の時に検証エラーを出すようにする。
task.rbに追加する。


## オリジナルの検証コードを書く
自分で検証コードを書く場合の書き方は2つある。

1. 検証を行うメソッドを追加して、そのメソッドを検証用のメソッドとして指定する。
2. 自前のvalidatorを作って利用する

今回は1の方法を利用する。
taskモデルに対して「タスクのname属性の値にはカンマが含まれていてはいけない」という検証を追加する。

検証を追加すすためのステップ
1. 検証用のメソッドをモデルクラスに登録する
2. 検証用のメソッドを実装する

検証のメソッドの基本的な仕事は「検証エラーを発見したら、errorsにエラー内容を格納する」
ここでは、nameにカンマが含まれている場合に、nameに関する検証エラーの詳細をerrors.addで格納している

## 検証がおこなwれない登録・更新操作もある
モデルの検証は、モデルの登録や更新のときに自動的に内部で呼ばれ、検証エラーがあればデータベースへの登録・更新が行われないというのが基本の形。
しかし、そのように自動で検証を行ってくれない登録・更新系のメソッドもrailsにはある。
ニーズに応じて利用するメソッドを適切に選択するようにすること

# 4-4 モデルの状態を自動的に制御する「コールバック」


railsは登録や削除などの重要なイベントの前後に処理を挟むことができる。
この仕組をコールバックという。

コールバックという言葉は然るべきタイミングが来たらこの処理を呼ぶ、というように後で読んでほしい処理を安宅じめ指定しておく仕組みを指すプログラミング用語。
railsのモデル層のコールバックはモデルオブジェクトの重要なイベントの前後に任意の処理をいくつでも呼び出せる仕組みとなっている

## トランザクション
トランザクション: 一連の複数の処理によるデータベースの整合性を保つための機能。

# 4-5 ログイン画面を作る

メールアドレスとパスワードの組み合わせによる認証をアプリケーションで実装していく

## セッションとcookie

### セッション
webアプリケーションはブラウザからサーバーへHTTPリクエストを送り、HTTPレスポンスを受け取って画面として表示する。
このHTTPリクエストを繰り返し行うことによって順番に操作を行っていく。
しかし、HTTPは状態を保持しないプロトコルなのでこのままでは、同じユーザーから送られた1つ目のリクエストがから2つ目のリクエストに情報を引き継ぐことができない。
そのため、webアプリケーションではサーバ側にセッションという仕組みを用意して、**1つのブラウザから連続して送られている一連のリクエストの間で状態を今日できるようにしている**。

railsでは、コントローラからsessionというメソッドを呼び出すことで、セッションにアクセスできる。
sessionはハッシュのように扱うことができる。

```
session[:user_id] = @user.id
```

値を取り出すには、次のように参照する

```
@user_id = session[:user_id]
```


## cookie

cookieでは、まずwebサーバーからブラウザへHTTPレスポンスを返す際に、何らかのcookie情報を含めて送る、
cookie情報はキーと値のペアの集合。
ブラウザはこのcookie情報を、サーバのドメインなどの情報に紐付けて保存する。
そして、次に同じドメインに対してHTTPリクエストを送る際に、保管していたcookie情報を添えて送る。
これによりwebサーバは、以前にどのようなcookie情報を受け取ったブラウザからリクエストが送られてきたのかを知ることができる。
cookie: **複数のリクエストの間で共有したい「状態」をブラウザ側に保存する仕組み**

## Userモデルを作る
認証機能を作るにはアプリケーションを利用するユーザーを表す新しい概念を加える必要がある。
そこで、ユーザーを表すUserモデルを作る。

digest: もとの値に戻すことができない一方的な変換(ハッシュ化)を行った文字列のこと

rails gコマンドを利用してUserモデルを作ってみる。
userテーブルを作るためのマイグレーションファイルとUserモデルが作られた。
このままmigrationと言いたいところだが、その前に少しマイグレーションファイルを編集する。
今回はユーザー情報とパスワードが入るので、値がNULLになることはない。また、同じメールアドレスを持つユーザーが複数人存在することもありえない。
なので、NULL等のありえない値が入ることを防ぐために編集する。

書き終えたら、migrationを実行する。

## パスワードを受け付けてdigestを保存する

ユーザーの名前やメールアドレスをデータベースに保存する仕組みは出来上がっているが、ユーザーが指定したパスワードをdigestに変換する仕組みがない。
どこで、パスワードの入力を受け付けてdigestを生成・保存するように実装を加えていく。

ハッシュ化にはhas_secure_passwordを利用する。
上記を利用してパスワードをハッシュ化するためにbcryptというgemを入れる必要がある。

モデルの中にhas_secure_passwordを記入するとデータベースのカラムには対応しない属性が2つ追加される
1. password(パスワードの値)
2. password_confirmation(確認用パスワードの保管。passwordの値と一致していなければ検証に失敗するようになる)


railsコンソールで値を保存する際の注意(153ページ,)
正しくは以下で保存する(.saveをつけていると、true/falseという値しか返ってこないためuser.password_digestを実行してもmethod errorを出される)

```
user = User.new(name: 'user_3', email: 'test_3@example.com', password: 'password', password_confirmation: 'password')
```


## ユーザー管理機能一式を追加する
アプリケーションの利用者をどうやってUserとしてデータベースに登録するかを検討する。
よくある形は以下2種類のユーザー登録方法

1. 未登録のユーザーが自らサインアップを行う
2. 登録者がユーザーを登録することで、ユーザーがアプリケーションを利用できるようにする

今回のアプリでは、管理者が存在し、管理者がブラウザからかんたんにユーザーの登録・編集・削除などが行えるようにする

### Userモデルにadminフラグを追加する
ユーザーが管理者かどうかを表すフラグを追加する。
g コマンドでマイグレーションファイルの雛形を作り編集する。
↑の操作では、usersテーブルにadminというフラグのカラムを追加する。

### ユーザー管理のためのコントローラを実装する
「管理系」の機能としてのユーザー管理を行うので、Admin::UsersControllerという名前をつける。
Admin::UsersControllerには、一般的なCRUDの機能をもたせることにする。


## ログイン画面を実装する
ログイン画面では、ユーザーがログインするためのフォーム画面を表示し、そこから送られてきた情報をもとにユーザーを認証する。さらに、ログアウトも提供する。

railsでログイン機能を実装する際は、ログインをする=「セッションというリソースを作る」と捉えて、SessionsControllerという名前でコントローラを作ることがよく行われる。

## ログインのフォームを表示する
コントローラと一緒にnewアクションとビューも作る

config/routes.rbを書き換えてURLを/loginにする。

## ログインの実行

createアクションではまず、送られてきたメールアドレスでユーザーを検索する。ユーザーが見つかった場合は、送られてきたパスワードによる認証をauthenticateメソッドを使って行う。

authenticateメソッドはUserクラスにhas_secure_passwordと記述したときに自動で追加された、認証のためのメソッド。
引数で受け取ったパスワードをハッシュ化して、その結果がUserオブジェクト自身を、一致していなければ認証失敗ということでfalseを返す。

なお、メールアドレスに対応するユーザーデータが見つからない時、userはnilになるので、authenticateメソッドを呼び出す部分ではボッチ演算子を使っている

認証に成功した場合、セッションにuser_idを格納する

このアプリケーションの状態
1. 誰もログインしていない状態。session[:user_id] がnil
2. 誰かがログインしている状態。session[:user_id]がログイン中のユーザーのIDが入っている

## ログイン情報の取得をかんたんにする
ユーザーがログインしていればsession[:user_id]にユーザーのIDが格納された状態となるので、ログイン後はセッションが生きている限り、下記のコードでユーザーをかんたんに取得することができる。

```
User.find_by(id: session[:user_id])
```

ログインしているユーザーを取得する処理は、頻繁に必要になるので、コントローラやビューからかんたんに呼べるようにするのが定石となっている。
かんたんな実装方法としては、ApplicationControllerにcurrent_userというような名前のメソッドを定義することで、すべてのコントローラから利用できるようにする。
さらに、helper_method指定をすることで、すべてのびゅーからもつかえるようにする。


## ログアウト機能を実装する
ログアウト機能: アプリケーションの状態を、ログインしている状態から櫓杭していない状態に変えること。
今回のアプリの場合は、session[:user_id]にnilが入っている状態にすればよいということになる。

セッションからuser_idの情報だけをピンポイントで消すには以下のようにするとできる。

```
session.delete(:user_id)
```

セッション内の情報をすべて削除する場合には以下のようにする。

```
reset_session
```

まず、ログアウトのためのルーティングを定義する。

## ログインしていなければタスク管理を利用できなくする
コントローラの「フィルタ」という機能を使う。
フィルタ: アクションを処理する前後に、任意の処理を挟む事ができる概念

今回は、タスク管理機能の各アクションの前に処理されるフィルタで、ユーザーがログインしているかどうかを調べ、ログインしていなければログイン画面に戻りリダイレクトさせ、タスク管理機能を実質利用できないようにする。

フィルタとしてメソッドを登録し、実際にそのメソッドを実装する、というやり方でフィルタを追加する。

今回はlogin_requiredという名前のメソッドをアクションの前に呼ばれるフィルタとして登録することにする
これにより、アプリケーション内のすべてのアクションの処理前に、ユーザーがログイン済みかどうかチェックがん済みでなかった場合にはログイン画面を表示するようになる。

## ログインしているユーザーのデータだけを扱えるようにする
特定のユーザーに紐付いたtaskデータだけを扱うようにプログラムを変更する

<主な変更点>
- userとtaskを紐付ける。具体的にはtasksテーブルにuser_idというカラムを追加して、タスクを所有しているユーザーのidが格納されるようにする
- userとtaskの紐付けをかんたんに扱えるよう、railsの関連を定義する
- ログインしているユーザーに紐付いたtaskデータを登録できるようにする
- 一覧、詳細、変更など既存のレコードを扱う機能では、ログインしているユーザーに紐づくデータだけを扱うようにする。

### データベース上でUserとTaskを紐付ける
1つのUserに対して複数のTaskが存在する一対多の関係になるので、「多」に当たるTask側に、Userを示す外部キーuser_idをもたせる。

`DELETE FROM tasks;`というSQLによって、今まで作られたタスクがすべて削除される。
これは、既存のタスクがある状態でカラムの追加を行うと、既存のタスクに紐づくユーザーを決められず、NOT NULL制約に引っかかってしまうため。


### railsの関連を定義する
railsには「関連(Association)」という仕組みが用意されており、データベース上の紐付けを前提にしてモデルクラス同士の紐付けを定義することができる。

UserとTaskは1対多の関係にある。

has_manyはそのクラス(ここではUser)のidを外部キーとして抱えているような他のクラス(ここではTask)があり、そのレコードが複数登録可能であることを表している。
いわば、子分的な存在が複数いるということを定義する。

belongs_toはそのクラス(ここではTask)は、ある別のクラス(ここではUser)に従属しており、従属先のクラスidを外部キーとして抱えていることを表す。
いわば、親分を指定するようなイメージ

このような定義をすることで、Userクラスのインスタンスに対しては、user.tasksといったメソッドで、紐付いたTaskオブジェクトの一覧を得られるようになる。また、Taskクラスのインスタンスに対しては、task.userで紐付いたUserオブジェクトを得られるようになる。


### ログインしているユーザーのTaskデータの登録
登録アクションを変更する。
(登録するTaskオブジェクトを準備している部分で、ログインしているユーザーのuser_idも代入する必要がある)

```
@task = current_user.tasks.new(task_params)
```


### ログインしているユーザーのTaskデータだけを読み出す
登録以外の機能についても考えていく。
変更、詳細、一覧、削除といった機能はすべて、データベースに保存されたTaskデータを取り出す処理を含んでいる。

ログインしているユーザーに紐づくデータだけを扱わせるようにするには、データベースからデータを取り出す処理に絞り込み条件を加える。

#### タスク一覧を変更する
タスク一覧に表示するTaskデータは、TasksControllerのindexアクションにおいて、データを取得している

```
def index
  @tasks = Task.all
end
```

これを、ログインしているユーザーに紐づくTaskだけを表示するように変更する。

```
@tasks = current_user.tasks
```

次にshow, edit, update, destroyのアクションコードを変更する
いずれのアクションの中にも以下のコードが出てくる。

```
Task.find(params[:id])
```

これは「指定したidのレコードをデータベースから取得する」ということを実現している。
このままでは、ユーザーが適当に入力したidが存在しているユーザーのものであった場合、その詳細情報をやすやすと見せてしまうことになる。

そこで以下のような変更を加える
これで、他のユーザーの情報を盗み見たり改ざんしようとした場合にも、そんなデータはないということではねつけることができる。

```
current_user.tasks.find(params[:id])
```

### 管理機能を管理者ユーザーだけに利用させるようにする
現在では、どんなユーザーもユーザー管理機能を使えてしまう状態にある。
そこで、管理権限のあるユーザーだけがユーザー管理情報を利用できるように修正していく。

ユーザー管理機能の修正に入る前に、ログインしているユーザーが管理権限を持っている場合のみ、ユーザー一覧画面へのリンクをメニューに表示させるようにしておく。

管理権限を持っているかどうかは、Userオブジェクトが持つadmin?メソッドで問い合わせることができる。
管理権限を持っている場合にはadmin?メソッドはtrueを返す。現在ログインしているユーザーはcurrent_userで取り出せるので、current_user.admin?で現在ログインしているユーザーの管理権限を問い合わせることができる。

次は管理権限を持っているユーザーだけがユーザー管理機能を利用できるようにする。
ユーザー管理機能に管理者以外の利用を禁止するフィルタとしてrequire_adminメソッドを追加する。

これで、ユーザー管理機能は管理権限を持っているユーザーだけが利用できるようになった。

### 最初の管理者ユーザーを作る
railsコンソールから管理者を作る
