この章でやること
マイグレーション理解の幅を広げる

# 4-1

## マイグレーションの適用を理解する
マイグレーションは基本的に以下の2ステップで行う
1. DBの構造を適用するコードをRubyで記述した「マイグレーション」ファイルを作成する
2. 削除したマイグレーションファイルをrails:db:migrateコマンドを使ってデータベースに適用する(migrateする)

マイグレーションにおいては1つのマイグレーションファイが**1つのバージョン**として扱われる。
つまり、1つのマイグレーションを適用することでデータベーススキーマのバージョンを1つ上げることができ、適用済みのマイグレーションを１つ取り消すことでバージョンを1つ下げることができる。

マイグレーションファイルを作成しただけではデータベースは変更されない。
マイグレーションを適用して初めて、マイグレーションファイルに書かれたrubyコードが実行され、データベースが実際に変更される。
逆にマイグレーションを取り消す際もマイグレーションを取り消すコマンドを実行してマイグレーションファイルに書かれた取り消し操作を適用する必要がある。


## マイグレーションの名前の付け方に注意
マイグレーションの名前はアプリケーション内で一意(オンリーワン)である必要がある。

## schema.rb
railsは現在のデータベースの構造をdb/schema.rbというファイルに自動出力する。
このファイルはマイグレーションを適用したり外したりすると自動的に出力される。
また、db:schema:dumpコマンドで手動で出力することもできる。
schema.rbは自動テスト環境などで使用される他、視覚的にテーブル・絡む構造を確認できるため、データベースについての手軽なドキュメントとして利用することもできる。


# 4-2
データの内容を制限数する

データには、想定される内容の範囲がある。
(カラムの値が常に数値なのか、値が入らないことがあるのか?)

内容の範囲の中にはデータベースで定義することでそぐわない値が格納されないようにできるものがある。
一般的には以下のような定義要素。

- データ型
- NOT NULL制約
- 文字列カラムの長さを指定する
- ユニークインデックス

## データ型
データベースのカラムには方を指定する。

## NOT NULL制約
データベーステーブルのカラムの値としてNULLを格納する必要がない場合には、NOT NULL制約をつけることで、物理的にNULLできないようにしてくれる。

### taskテーブルのnameカラムにNOT NULL制約をつける
すでに作ってあるテーブルのカラムに後から制約をつける際にもマイグレーションを利用する。
まずはマイグレーションの雛形ファイルを作る。
マイグレーションの雛形を作ったら、生成したファイルの中身を変更する。
(書籍参照)
change_column_nullを使うと、既存のテーブルの既存のカラムのNOYT NULL制約をつけたり外したりすることができる。
編集したら、マイグレーションをデータベースに適用する。


## 文字列カラムの長さを指定する
絡む定義で文字列の長さを指定することで、必要以上に長いデータ保存されることを防ぐ事ができる。
マイグレーションで文字列カラムに対して文字列の長さを指定するには、limitオプションを使う。


## ユニークインデックスを作成する
カラムのデータが全レコード内で一意である場合には、データベースにユニークインデックスを作成することで、一意性が壊されるのを防ぐことができる。

仮にTaskモデルのname属性をシステム内で一意にしたいとすれば、taskテーブル作成時にnameカラムに対してユニークインデックスを作成するのが良い

# モデルの「検証」を使う
データの内容が正しいかどうかをチェックする仕組みのことを検証(validation)という
railsのモデルにも検証の仕組み通いされている。


## モデルの検証の仕組み
railsにおけるモデルの検証は基本的に「モデルオブジェクトをデータベースに登録・更新する前に検証を行い、エラーがあれば登録・更新をしないで差し戻す」という仕組みになっている。
この仕組に対応する登録・更新のためのメソッドがsave。

saveメソッド: データベースの登録・更新を行う前に自動的に検証を行い、検証エラーがあればfalseを返す。
検証エラーがなければ、データベースへの登録・更新を行ってtrueを返す。

検証は、検証処理単独でも呼ぶことができる。それにはvalid?というメソッドを利用する。

## 検証の書き方
検証コードを書く方法には大きくわけて2通りある

1. railsが用意している検証用のヘルパーを利用する
2. 自分で任意の検証コードを書く

webアプリケーションでよくある検証要件に対しては、railsが検証用のヘルパーを用意してくれている。


## 検証を追加する
例として「taskleafアプリケーションのTaskモデルのname属性の値が入っていなければ検証エラーになる」という検証を追加してみる。


## コントローラとビューで検証エラーに対応する

tasks_controlloer.rbを変更する

<変更点>

1. 登録のために用いるメソッドの変更
save!ではなくsaveを利用して、どの戻り値によって制御を変えるようにしている

2. 検証エラーのときの処理の追加
結果がfalseだったときは、render :newによって、登録用のフォーム画面を再び表示て、ユーザー二再入力を促す

3. Taskオブジェクトを@taskというインスタンス変数に代入するようにする
検証エラーがあってもう一度新規登録画面を表示する際に、ビューに検証を行った現物のTaskオブジェクトを渡す必要があるから。


## 文字列長の検証を追加する
30文字を超える入力の時に検証エラーを出すようにする。
task.rbに追加する。


## オリジナルの検証コードを書く
自分で検証コードを書く場合の書き方は2つある。

1. 検証を行うメソッドを追加して、そのメソッドを検証用のメソッドとして指定する。
2. 自前のvalidatorを作って利用する

今回は1の方法を利用する。
taskモデルに対して「タスクのname属性の値にはカンマが含まれていてはいけない」という検証を追加する。

検証を追加すすためのステップ
1. 検証用のメソッドをモデルクラスに登録する
2. 検証用のメソッドを実装する

検証のメソッドの基本的な仕事は「検証エラーを発見したら、errorsにエラー内容を格納する」
ここでは、nameにカンマが含まれている場合に、nameに関する検証エラーの詳細をerrors.addで格納している

## 検証がおこなwれない登録・更新操作もある
モデルの検証は、モデルの登録や更新のときに自動的に内部で呼ばれ、検証エラーがあればデータベースへの登録・更新が行われないというのが基本の形。
しかし、そのように自動で検証を行ってくれない登録・更新系のメソッドもrailsにはある。
ニーズに応じて利用するメソッドを適切に選択するようにすること
